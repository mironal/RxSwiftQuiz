//
//  Basic_FlatMap.swift
//  RxSwiftQuizTests
//
//

import RxBlocking
import RxSwift
import RxTest
import XCTest

class Basic_FlatMap: XCTestCase {
    var asyncRequestCallCount = 0
    func asyncRequest(_ num: Int) -> Observable<Int> {
        .just(num * 10)
            .delay(.milliseconds(num), scheduler: ConcurrentDispatchQueueScheduler(qos: .default))
            .do(onNext: { [weak self] _ in self?.asyncRequestCallCount += 1 })
    }

    /*

     !! Here are some tips and answers !!

     https://github.com/mironal/RxSwiftQuiz/blob/main/Answers/Answers_Basic_FlatMap.md

      */

    override func setUpWithError() throws {
        asyncRequestCallCount = 0
    }

    func test1() throws {
        // それぞれの値をシーケンスに2回ずつ流します
        // Send each value to the sequence twice.

        let answer = Observable.of(1, 2, 3)
            // Rewrite the code in `flatMap` so that the test passes.
            .flatMap {
                Observable.just($0)
            }

        // ↓↓ Please do not edit below from here ↓↓

        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(result, [1, 1, 2, 2, 3, 3])
    }

    func test2() throws {
        // flatMap を使って奇数だけのシーケンスを作ります (filter と同様の処理です)
        // Use `flatMap` to create an odd-number sequence (similar to filter).

        let answer = Observable.of(1, 2, 3)
            // Rewrite the code in `flatMap` so that the test passes.
            .flatMap { num -> Observable<Int> in
                Observable.just(num)
            }

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(result, [1, 3])
    }

    func test3() throws {
        // compactMap を使って奇数だけのシーケンスを作ります
        // Use `compactMap` to create an odd-number sequence (similar to filter).

        let answer = Observable.of(1, 2, 3)
            // Rewrite the code in `compactMap` so that the test passes.
            .compactMap { num -> Int? in
                num
            }

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(result, [1, 3])
    }

    func test4() throws {
        // `map { self.asyncRequest($0) }` で生成した全ての `Observable` の完了を待ちます。
        // シーケンスには `asyncRequest` が完了した順に値が流れます。

        // Wait for the completion of all `Observable`s generated by `map { self.asyncRequest ($ 0) }`.
        // Values flow in the sequence in the order that `asyncRequest` is **completed**.

        let answer = Observable.of(3, 2, 1)
            .map { self.asyncRequest($0) } // <- Do not edit this line.
            .map { _ in 0 } // <- Delete this line and fix it so that the test passes.

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(asyncRequestCallCount, 3)
        XCTAssertEqual(result, [10, 20, 30])
    }

    func test5() throws {
        // `map { self.asyncRequest($0) }` で生成した全ての `Observable` の完了を待ちます。
        // シーケンスには `asyncRequest` を実行した順に値が流れます。

        // Wait for the completion of all `Observable`s generated by `map { self.asyncRequest ($ 0) }`.
        // Values flow in the sequence in the order in which `asyncRequest` is **executed**.

        let answer = Observable.of(3, 2, 1)
            .map { self.asyncRequest($0) } // <- Do not edit this line.
            .map { _ in 0 } // <- Delete this line and fix it so that the test passes.

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(asyncRequestCallCount, 3)
        XCTAssertEqual(result, [30, 20, 10])
    }

    func test6() throws {
        // Do the same thing as test4 with one Operator

        let answer = Observable.of(3, 2, 1) // Write only one operator below this to pass the test.

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(asyncRequestCallCount, 3)
        XCTAssertEqual(result, [10, 20, 30])
    }

    func test7() throws {
        // Do the same thing as test5 with one Operator

        let answer = Observable.of(3, 2, 1) // Write only one operator below this to pass the test.

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(asyncRequestCallCount, 3)
        XCTAssertEqual(result, [30, 20, 10])
    }

    func test8() throws {
        // `map { self.asyncRequest($0) }` で生成した全ての `Observable` の完了を待ちます。
        // ただしシーケンスには最後の1つ(3に対応する結果)だけを流し、それ以外の `asyncRequest` の実行はキャンセルされるようにします。

        // Wait for the completion of all `Observable`s generated by `map { self.asyncRequest ($ 0) }`.
        // However, only the last one (result corresponding to 3) is sent to the sequence,
        // and the execution of the other `asyncRequest` is canceled.

        let answer = Observable.of(1, 2, 3)
            .map { self.asyncRequest($0) } // <- Do not edit this line.
            .map { _ in 0 } // <- Delete this line and fix it so that the test passes.

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(asyncRequestCallCount, 1, "Run only once and cancel others")
        XCTAssertEqual(result, [30])
    }

    func test9() throws {
        // Do the same thing as test8 with one Operator

        let answer = Observable.of(1, 2, 3) // Write only one operator below this to pass the test.

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(asyncRequestCallCount, 1, "Run only once and cancel others")
        XCTAssertEqual(result, [30])
    }

    func test10() throws {
        // 最後の結果ではなく最初の結果をシーケンスに流します。
        // Only the first result, not the last result, is sent to the sequence.

        let answer = Observable.of(1, 2, 3) // Write only one operator below this to pass the test.
            .map { _ in 0 } // <- Delete this line and fix it so that the test passes.

        // ↓↓ Please do not edit below from here ↓↓
        let result = try answer
            .toBlocking()
            .toArray()

        XCTAssertEqual(asyncRequestCallCount, 1, "Run only once and cancel others")
        XCTAssertEqual(result, [10])
    }
}
